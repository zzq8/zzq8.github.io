import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as t,a as n}from"./app-CC13KDKU.js";const r={},p=n('<h1 id="interview" tabindex="-1"><a class="header-anchor" href="#interview"><span>Interview</span></a></h1><h1 id="_01-谈谈你对java平台的理解" tabindex="-1"><a class="header-anchor" href="#_01-谈谈你对java平台的理解"><span>01 谈谈你对Java平台的理解？</span></a></h1><p>从你接触 Java 开发到现在，你对 Java 最直观的印象是什么呢？是它宣传的 “Write once, run anywhere”，还是目前看已经有些过于形式主义的语法呢？你对于 Java 平台到底了解到什么程度？请你先停下来总结思考一下。</p><p>今天我要问你的问题是，谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？</p><h2 id="典型回答" tabindex="-1"><a class="header-anchor" href="#典型回答"><span>典型回答</span></a></h2><p>Java 本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“<strong>书写一次，到处运行</strong>”（Write once, run anywhere），能够非常容易地获得跨平台能力；另外就是<strong>垃圾收集</strong>（GC, Garbage Collection），Java 通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。</p><p>对于“Java 是解释执行”这句话，这个说法不太准确。我们开发的 Java 的源代码，首先通过 Javac 编译成为字节码（bytecode），然后，在运行时，通过 Java 虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的 JVM，比如我们大多数情况使用的 Oracle JDK 提供的 Hotspot JVM，都提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于<strong>编译执行</strong>，而不是解释执行了。</p><h2 id="知识扩展" tabindex="-1"><a class="header-anchor" href="#知识扩展"><span>知识扩展</span></a></h2><p><mark>编译 Java 源码生成“.class”文件里面实际是字节码，而不是可以直接执行的机器码</mark></p><p>在运行时，JVM 会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。就像我前面提到的，主流 Java 版本中，如 JDK 8 实际是解释和编译混合的一种模式，即所谓的混合模式（-Xmixed）。</p><p>Java 虚拟机启动时，可以指定不同的参数对运行模式进行选择。 比如，指定“-Xint”，就是告诉 JVM 只进行解释执行，不对代码进行编译，这种模式抛弃了 JIT 可能带来的性能优势。毕竟解释器（interpreter）是逐条读入，逐条解释运行的。与其相对应的，还有一个“-Xcomp”参数，这是告诉 JVM 关闭解释器，不要进行解释执行，或者叫作最大优化级别。那你可能会问这种模式是不是最高效啊？简单说，还真未必。“-Xcomp”会导致 JVM 启动变慢非常多，同时有些 JIT 编译器优化方式，比如分支预测，如果不进行 profiling，往往并不能进行有效优化。</p><h1 id="_04-强引用、软引用、弱引用、幻象引用有什么区别" tabindex="-1"><a class="header-anchor" href="#_04-强引用、软引用、弱引用、幻象引用有什么区别"><span>04 强引用、软引用、弱引用、幻象引用有什么区别？</span></a></h1><p>在 Java 语言中，除了原始数据类型的变量，其他所有都是所谓的引用类型，指向各种不同的对象，理解引用对于掌握 Java 对象生命周期和 JVM 内部相关机制非常有帮助。</p><p>今天我要问你的问题是，<strong>强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？</strong></p><h2 id="典型回答-1" tabindex="-1"><a class="header-anchor" href="#典型回答-1"><span>典型回答</span></a></h2><p>不同的引用类型，主要体现的是<strong>对象不同的可达性（reachable）状态和对垃圾收集的影响。</strong></p><p>所谓强引用（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</p><p>软引用（SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>弱引用（WeakReference）并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。</p><p>对于幻象引用，有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制，我在专栏上一讲中介绍的 Java 平台自身 Cleaner 机制等，也有人利用幻象引用监控对象的创建和销毁。</p><h2 id="考点分析" tabindex="-1"><a class="header-anchor" href="#考点分析"><span>考点分析</span></a></h2><p>这道面试题，属于既偏门又非常高频的一道题目。说它偏门，是因为在大多数应用开发中，很少直接操作各种不同引用，虽然我们使用的类库、框架可能利用了其机制。它被频繁问到，是因为这是一个综合性的题目，既考察了我们对基础概念的理解，也考察了对底层对象生命周期、垃圾收集机制等的掌握。</p><p>充分理解这些引用，对于我们设计可靠的缓存等框架，或者诊断应用 OOM 等问题，会很有帮助。比如，诊断 MySQL connector-j 驱动在特定模式下（useCompression=true）的内存泄漏问题，就需要我们理解怎么排查幻象引用的堆积问题。</p><h1 id="_06-动态代理是基于什么原理" tabindex="-1"><a class="header-anchor" href="#_06-动态代理是基于什么原理"><span>06 动态代理是基于什么原理？</span></a></h1><p>编程语言通常有各种不同的分类角度，动态类型和静态类型就是其中一种分类角度，简单区分就是语言类型信息是在运行时检查，还是编译期检查。</p><p>与其近似的还有一个对比，就是所谓强类型和弱类型，就是不同类型变量赋值时，是否需要显式地（强制）进行类型转换。</p><p>那么，如何分类Java语言呢？通常认为，Java是静态的强类型语言，但是因为提供了类似反射等机制，也具备了部分动态类型语言的能力。</p><p>言归正传，今天我要问你的问题是，谈谈Java反射机制，动态代理是基于什么原理？</p><h2 id="典型回答-2" tabindex="-1"><a class="header-anchor" href="#典型回答-2"><span>典型回答</span></a></h2><p>反射机制是Java语言提供的一种基础功能，赋予程序在运行时<strong>自省</strong>（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p><p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装RPC调用、面向切面的编程（AOP）。</p><p>实现动态代理的方式很多，比如JDK自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似ASM、cglib（基于ASM）、Javassist等。</p><h2 id="考点分析-1" tabindex="-1"><a class="header-anchor" href="#考点分析-1"><span>考点分析</span></a></h2><p>这个题目给我的第一印象是稍微有点诱导的嫌疑，可能会下意识地以为动态代理就是利用反射机制实现的，这么说也不算错但稍微有些不全面。功能才是目的，实现的方法有很多。总的来说，这道题目考察的是Java语言的另外一种基础机制： 反射，它就像是一种魔法，引入运行时自省能力，赋予了Java语言令人意外的活力，<mark>通过运行时操作元数据或对象</mark>，Java可以灵活地操作运行时才能确定的信息。而动态代理，则是延伸出来的一种广泛应用于产品开发中的技术，很多繁琐的重复编程，都可以被动态代理机制优雅地解决。</p><p>从考察知识点的角度，这道题涉及的知识点比较庞杂，所以面试官能够扩展或者深挖的内容非常多，比如：</p><ul><li>考察你对反射机制的了解和掌握程度。</li><li>动态代理解决了什么问题，在你业务系统中的应用场景是什么？</li><li>JDK动态代理在设计和实现上与cglib等方式有什么不同，进而如何取舍？</li></ul><p>这些考点似乎不是短短一篇文章能够囊括的，我会在知识扩展部分尽量梳理一下。</p><p>XD：JavaGuide 泛型擦除中，就是用动态代理验证的！</p><h2 id="知识扩展-1" tabindex="-1"><a class="header-anchor" href="#知识扩展-1"><span>知识扩展</span></a></h2><ol><li>动态代理</li></ol><p>前面的问题问到了动态代理，我们一起看看，它到底是解决什么问题？</p><p>首先，它是一个<strong>代理机制</strong>。如果熟悉设计模式中的代理模式，我们会知道，代理可以看作是对调用目标的一个包装，这样我们对目标代码的调用不是直接发生的，而是通过代理完成。其实很多动态代理场景，我认为也可以看作是<mark>装饰器（Decorator）模式</mark>的应用，我会在后面的专栏设计模式主题予以补充。</p><p>通过代理可以让调用者与实现者之间<strong>解耦</strong>。比如进行RPC调用，框架内部的寻址、序列化、反序列化等，对于调用者往往是没有太大意义的，通过代理，可以提供更加友善的界面。</p><h1 id="_10-如何保证集合是线程安全的-concurrenthashmap如何实现高效地线程安全" tabindex="-1"><a class="header-anchor" href="#_10-如何保证集合是线程安全的-concurrenthashmap如何实现高效地线程安全"><span>10 如何保证集合是线程安全的_ ConcurrentHashMap如何实现高效地线程安全？</span></a></h1><p>我在之前两讲介绍了Java集合框架的典型容器类，它们绝大部分都不是线程安全的，仅有的线程安全实现，比如Vector、Stack，在性能方面也远不尽如人意。幸好Java语言提供了并发包（java.util.concurrent），为高度并发需求提供了更加全面的工具支持。</p><p>今天我要问你的问题是，如何保证容器是线程安全的？ConcurrentHashMap如何实现高效地线程安全？</p><h2 id="典型回答-3" tabindex="-1"><a class="header-anchor" href="#典型回答-3"><span>典型回答</span></a></h2><p>Java提供了不同层面的线程安全支持。在传统集合框架内部，除了Hashtable等同步容器，还提供了所谓的同步包装器（Synchronized Wrapper），我们可以调用Collections工具类提供的包装方法，来获取一个同步的包装容器（如Collections.synchronizedMap），<strong>但是它们都是利用非常粗粒度的同步方式，在高并发情况下，性能比较低下。</strong></p><p>另外，更加普遍的选择是利用并发包提供的线程安全容器类，它提供了：</p><ul><li>各种并发容器，比如<mark>ConcurrentHashMap、CopyOnWriteArrayList</mark>。</li><li>各种线程安全队列（Queue/Deque），如ArrayBlockingQueue、SynchronousQueue。</li><li>各种有序容器的线程安全版本等。</li></ul><p>具体保证线程安全的方式，包括有从简单的synchronize方式，到基于更加精细化的，比如基于分离锁实现的ConcurrentHashMap等并发实现等。具体选择要看开发的场景需求，总体来说，并发包内提供的容器通用场景，远优于早期的简单同步实现。</p>',51),i=[p];function o(s,l){return e(),t("div",null,i)}const d=a(r,[["render",o],["__file","Java 核心技术面试精讲.html.vue"]]),v=JSON.parse('{"path":"/studynotes/JavaSE/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2.html","title":"Interview","lang":"zh-CN","frontmatter":{"description":"Interview 01 谈谈你对Java平台的理解？ 从你接触 Java 开发到现在，你对 Java 最直观的印象是什么呢？是它宣传的 “Write once, run anywhere”，还是目前看已经有些过于形式主义的语法呢？你对于 Java 平台到底了解到什么程度？请你先停下来总结思考一下。 今天我要问你的问题是，谈谈你对 Java 平台的理解...","head":[["meta",{"property":"og:url","content":"https://doc.zzq8.cn/studynotes/JavaSE/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2.html"}],["meta",{"property":"og:site_name","content":"Zz"}],["meta",{"property":"og:title","content":"Interview"}],["meta",{"property":"og:description","content":"Interview 01 谈谈你对Java平台的理解？ 从你接触 Java 开发到现在，你对 Java 最直观的印象是什么呢？是它宣传的 “Write once, run anywhere”，还是目前看已经有些过于形式主义的语法呢？你对于 Java 平台到底了解到什么程度？请你先停下来总结思考一下。 今天我要问你的问题是，谈谈你对 Java 平台的理解..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-13T08:39:03.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-13T08:39:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Interview\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-13T08:39:03.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"典型回答","slug":"典型回答","link":"#典型回答","children":[]},{"level":2,"title":"知识扩展","slug":"知识扩展","link":"#知识扩展","children":[]},{"level":2,"title":"典型回答","slug":"典型回答-1","link":"#典型回答-1","children":[]},{"level":2,"title":"考点分析","slug":"考点分析","link":"#考点分析","children":[]},{"level":2,"title":"典型回答","slug":"典型回答-2","link":"#典型回答-2","children":[]},{"level":2,"title":"考点分析","slug":"考点分析-1","link":"#考点分析-1","children":[]},{"level":2,"title":"知识扩展","slug":"知识扩展-1","link":"#知识扩展-1","children":[]},{"level":2,"title":"典型回答","slug":"典型回答-3","link":"#典型回答-3","children":[]}],"git":{"createdTime":1712997543000,"updatedTime":1712997543000,"contributors":[{"name":"Fighting","email":"1024zzq@gmail.com","commits":1}]},"readingTime":{"minutes":10.06,"words":3019},"filePathRelative":"studynotes/JavaSE/Java 核心技术面试精讲.md","localizedDate":"2024年4月13日","autoDesc":true}');export{d as comp,v as data};
