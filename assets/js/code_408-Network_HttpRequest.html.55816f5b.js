"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[8407],{9874:(e,i)=>{i.A=(e,i)=>{const t=e.__vccOpts||e;for(const[e,l]of i)t[e]=l;return t}},2940:(e,i,t)=>{t.r(i),t.d(i,{comp:()=>h,data:()=>u});var l=t(2360);const s=(0,l.Fv)('<h1 id="httprequest" tabindex="-1"><a class="header-anchor" href="#httprequest"><span>HttpRequest</span></a></h1><p><a href="https://blog.csdn.net/f110300641/article/details/115342356" target="_blank" rel="noopener noreferrer">http 请求包含哪几个部分（请求行、请求头、请求体）</a></p><blockquote><p>这里放一些常见的，具体的去搜</p></blockquote><h2 id="一、general-请求行" tabindex="-1"><a class="header-anchor" href="#一、general-请求行"><span>一、General（请求行）</span></a></h2><ul><li><p>Request URL: http://127.0.0.1:8848/nacos/</p></li><li><p>Request Method: GET</p></li><li><p>Status Code:304（响应状态码）</p></li><li><p>Remote Address: 127.0.0.1:8848（HTTP请求的源地址）</p><ul><li><p>HTTP协议在三次握手时使用的就是这个Remote Address地址，在发送响应报文时也是使用这个Remote Address地址。因此，如果请求者伪造Remote Address地址，他将无法收到HTTP的响应报文，此时伪造没有任何意义。这也就使得Remote Address默认具有防篡改的功能。</p></li><li><p>如果http请求经过代理服务器转发，用户的真实ip会丢失，为了避免这个情况，代理服务器通常会增加一个叫做x_forwarded_for的头信息，把连接它的客户端IP（即你的上网机器IP）加到这个头信息里，这样就能保证网站的web服务器能获取到真实IP</p></li></ul></li><li><p>Referrer Policy: strict-origin-when-cross-origin（引用策略，有八种）</p><ul><li>Referer提供访问来源的信息，告诉服务器，用户在访问当前资源之前的位置，发生传场景包含：加载图片、样式文件、JS文件、请求。浏览器会将当前网址作为Referer字段，<strong>放在 HTTP 请求的头信息发送</strong></li></ul></li></ul><h2 id="二、request-headers-请求头" tabindex="-1"><a class="header-anchor" href="#二、request-headers-请求头"><span>二、Request Headers（请求头）</span></a></h2><ul><li><p><code>Accept</code>: text/html, application/xhtml+xml, application/xml;q=0.9, <em>/</em>;q=0.8</p><ul><li>请求头用来告知服务器 客户端可以处理的内容类型(用MIME类型来表示)，借助内容协商机制服务器从备选项中选择一项进行应用，并使用Content-Type应答头通知客户端它的选择。</li></ul></li><li><p>Accept-Encoding: gzip, deflate, br</p><ul><li>请求头用来告知服务器 客户端可以处理的编码方式</li></ul></li><li><p>Accept-Language: zh-CN,zh-TW;q=0.9,zh;q=0.8,en;q=0.7</p></li><li><p>Cache-Control: max-age=0</p></li><li><p>Content-Type：xxx 这个补充到笔记，请求也有这不光response</p></li><li><p>Connection: keep-alive</p><ul><li><p>面试常问1.1和1.0的区别。。有必要说明的是，HTTP/1.0 仍提供了长连接选项，即在请求头中加入<code>Connection: Keep-alive</code>。同样的，在 HTTP/1.1 中，如果不希望使用长连接选项，也可以在请求头中加入<code>Connection: close</code>，这样会通知服务器端：“我不需要长连接，连接成功后即可关闭”。</p><hr><p>著作权归Guide所有 原文链接：https://javaguide.cn/cs-basics/network/http1.0-vs-http1.1.html#%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F</p></li></ul></li><li><p><code>Cookie</code>: JSESSIONID=B4717473F69FD975072100C7E181E807; JSESSIONID=BF468917A7A82EB64D8E913D8F4457F5</p><ul><li>这两个Name一样但是Path不一样</li><li><mark>Cookie是Web服务器发送给客户端的一小段信息，客户端请求时，可以读取该信息发送到服务器端</mark></li></ul></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DNT" target="_blank" rel="noopener noreferrer">DNT</a>: 1 （<strong>D</strong>o <strong>N</strong>ot <strong>T</strong>rack）</p><ul><li>**已弃用：**不再推荐此功能。尽管某些浏览器可能仍然支持它</li></ul></li><li><p><code>Host</code>: 127.0.0.1:8848</p><ul><li>场景：Ngixn 转发会丢失这个，需配置的时候加个参数set上去</li></ul></li><li><p>If-Modified-Since: Fri, 29 Apr 2022 02:20:32 GMT</p></li><li><p>Referer: https://www.csdn.net/</p><ul><li><p>一般是主域名地址</p></li><li><p>有些网站请求硬性要加不然 - Err: 请求有安全风险,阻断请求</p><ul><li><p>HTTP请求头中的Referer字段的作用主要是告知服务器请求的来源页面。具体来说，它包含了发出请求的网页的URL</p></li><li><p>防盗链、安全和权限控制</p></li></ul></li></ul></li><li><p>Sec-Fetch-Dest: document</p></li><li><p>Sec-Fetch-Mode: navigate</p></li><li><p>Sec-Fetch-Site: same-origin</p></li><li><p>Sec-Fetch-User: ?1</p></li><li><p>Upgrade-Insecure-Requests: 1</p></li><li><p>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 sec-ch-ua: &quot;Not?A_Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;108&quot;, &quot;Google Chrome&quot;;v=&quot;108&quot;</p></li><li><p>sec-ch-ua-mobile: ?0</p></li><li><p>sec-ch-ua-platform: &quot;Windows&quot;</p></li></ul><h2 id="三、response-headers-响应头" tabindex="-1"><a class="header-anchor" href="#三、response-headers-响应头"><span><a href="https://www.runoob.com/http/http-header-fields.html" target="_blank" rel="noopener noreferrer">三、Response Headers（响应头）</a></span></a></h2><blockquote><p>包含服务器类型，日期，长度，内容类型等</p><p>响应正文响应正文就是服务器返回的HTML页面或者json数据 text/html application/json</p></blockquote><ul><li><p>Connection: keep-alive</p><ul><li>可以看到请求头也有这个属性</li><li>服务器可以解析请求头中的 Connection 字段来了解客户端的连接偏好，并相应地处理连接的保持与关闭。</li></ul></li><li><p>Content-Encoding: gzip</p></li><li><p>Content-Language: zh-CN</p></li><li><p><code>Content-Type</code>: text/html;charset=utf-8</p><ul><li>对应请求头的 Accept 告诉你采用的是哪个</li></ul></li><li><p>Date: Thu, 12 Jan 2023 08:27:16 GMT</p></li><li><p><code>Set-Cookie</code>: xxx</p><ul><li>设置和页面关联的Cookie</li></ul></li><li><p>Content-Length: 6867</p></li><li><p>Keep-Alive: timeout=60</p><ul><li><p>这意味着在客户端与服务器之间的通信中，如果在 60 秒内没有新的请求或响应发生，连接可能会被关闭。</p></li><li><p>CATIC 商网就是做了这个限制，然后直接报错 504 (Gateway Time-out) 但实际上，你只要请求丢过去了他后台服务器就还在执行。返回值如果不重要的话，我这里就是 return true 不太重要 响应值丢了就丢了 反正接口幂等了</p></li><li><p><strong>Response Headers的参数Keep-Alive: timeout=60该在哪里设置</strong></p><ul><li><p><strong>---对于Apache服务器：</strong> 对于 Apache Tomcat，你可以通过修改 <code>server.xml</code> 文件来配置</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span></span>\n<span class="line"><span>           connectionTimeout=&quot;60&quot; /&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>---对于Nginx服务器：</strong> 在 Nginx 的配置文件（通常是 <code>nginx.conf</code> 或位于 <code>sites-available</code> 目录中的虚拟主机配置文件）中，可以添加以下指令来设置 <code>Keep-Alive</code> 的超时时间：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>keepalive_timeout 60s;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上述配置中，<code>keepalive_timeout</code> 设置为 <code>60s</code> 表示超时时间为60秒。</p><p>请注意，以上配置示例仅供参考，实际配置可能会根据你的服务器环境和需求而有所不同。在修改服务器配置之前，请确保备份现有配置文件，并确保你对服务器配置有足够的了解。</p><p>完成配置更改后，重新启动服务器以使更改生效。之后，服务器会在响应头中包含 <code>Keep-Alive: timeout=60</code>，指示客户端保持持久连接的时间为60秒。</p></li></ul></li></ul></li></ul><hr>',11),a=(0,l.Fv)('<h2 id="四、xhr" tabindex="-1"><a class="header-anchor" href="#四、xhr"><span>四、<a href="https://zh.wikipedia.org/wiki/XMLHttpRequest" target="_blank" rel="noopener noreferrer">XHR </a></span></a></h2><blockquote><p>XMLHttpRequest</p><p>https://www.cnblogs.com/xiaohuochai/p/6036475.html</p><p>概括起来，就是一句话，ajax通过原生的<code>XMLHttpRequest</code>对象发出HTTP请求，得到服务器返回的数据后，再进行处理</p><p>Chrome F12 筛选请求的时候可以勾这个(就只会捕获 Ajax 请求)，其实本质是 ajax 核心。。。。我理解为所有交互的请求都是这个 ajax技术的核心是XMLHttpRequest对象(简称XHR)</p></blockquote><hr><p>http协议本身是一种无状态的协议</p><p>会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。 HTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。 有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。 1）.隐藏表单域：<input type="hidden">，非常适合步需要大量数据存储的会话应用。 2）.URL 重写:URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。 3）.Cookie:一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP 响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个 Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至 在客户端计算机重启后它仍可以保留其值 4）.Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话</p><h2 id="session-缺点" tabindex="-1"><a class="header-anchor" href="#session-缺点"><span>Session 缺点</span></a></h2><blockquote><p><strong>其实Session是依据Cookie来识别是否是同一个用户</strong>。</p></blockquote><h3 id="为什么要使用session技术" tabindex="-1"><a class="header-anchor" href="#为什么要使用session技术"><span>为什么要使用Session技术？</span></a></h3><p><strong>Session比Cookie使用方便，Session可以解决Cookie解决不了的事情【Session可以存储对象，Cookie只能存储字符串。】。</strong></p><h3 id="sessin-缺点" tabindex="-1"><a class="header-anchor" href="#sessin-缺点"><span>Sessin 缺点：</span></a></h3>',10),o=(0,l.Lk)("strong",null,"Session",-1),n=(0,l.Lk)("strong",null,"认证用户的增多，服务端的开销会明显增大",-1),r=(0,l.Lk)("li",null,[(0,l.Lk)("strong",null,"CSRF"),(0,l.eW)(": 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到"),(0,l.Lk)("strong",null,"跨站请求伪造的攻击")],-1),p=(0,l.Lk)("li",null,[(0,l.Lk)("strong",null,[(0,l.Lk)("mark",null,"扩展性")]),(0,l.eW)(": 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户"),(0,l.Lk)("strong",null,"下次请求还必须要请求在这台服务器上"),(0,l.eW)(",这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。")],-1),c=(0,l.Fv)('<p>解决系统之间Session不共享问题：把Session数据放在Redis中（使用Redis模拟Session）【<strong>建议</strong>】</p><p>针对Cookie存在跨域问题，有几种解决方案：</p><ol><li>服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上就行了</li><li>多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。</li><li>将Token保存在SessionStroage中（不依赖Cookie就没有跨域的问题了）</li></ol><h2 id="cookie" tabindex="-1"><a class="header-anchor" href="#cookie"><span><a href="https://mp.weixin.qq.com/s/JW7mxXEqrV1rZ_pQOteXGQ" target="_blank" rel="noopener noreferrer">Cookie</a></span></a></h2><h2 id="token" tabindex="-1"><a class="header-anchor" href="#token"><span>token</span></a></h2><blockquote><p>JWT -- JSON WEB TOKEN</p></blockquote><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p><p>流程上是这样的：</p><ul><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个token</li><li>客户端存储token，并在每次请求时附送上这个token值</li><li>服务端验证token值，并返回数据</li></ul><p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持<code>CORS(跨来源资源共享)</code>策略，一般我们在服务端这么做就可以了<code>Access-Control-Allow-Origin: *</code>。</p><h2 id="计网面试题" tabindex="-1"><a class="header-anchor" href="#计网面试题"><span>计网面试题</span></a></h2><h3 id="tcp和udp的区别-tcp靠什么保证可靠连接" tabindex="-1"><a class="header-anchor" href="#tcp和udp的区别-tcp靠什么保证可靠连接"><span>TCP和UDP的区别，TCP靠什么保证可靠连接？</span></a></h3><blockquote><p>TCP通过以下机制来保证可靠连接：</p><ol><li>序列号和确认应答：TCP将每个发送的数据包进行编号，接收方通过发送确认应答来确认已接收到的数据包。发送方根据确认应答确定是否需要重传丢失的数据包。</li><li>重传机制：如果发送方未收到确认应答或检测到数据包丢失，它会自动重传该数据包，确保数据的可靠传输。</li><li>滑动窗口：TCP使用滑动窗口机制来控制发送方发送的数据量，以适应网络的拥塞情况，保证发送速率与接收速率的匹配。</li><li>拥塞控制：TCP通过拥塞窗口和拥塞避免算法来控制发送速率，避免网络拥塞并保证整体性能。</li></ol></blockquote><h3 id="讲一下tcp三次握手-为什么要3次-两次或者四次不行吗" tabindex="-1"><a class="header-anchor" href="#讲一下tcp三次握手-为什么要3次-两次或者四次不行吗"><span>讲一下TCP三次握手 为什么要3次，两次或者四次不行吗</span></a></h3><p>TCP 建立连接时，通过三次握手能<strong>防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p><h2 id="base64" tabindex="-1"><a class="header-anchor" href="#base64"><span>Base64</span></a></h2><p>介绍：</p><ul><li>base64 - <mark>只是一种编码方法，并不是加密算法</mark> 所有的数据都是明文存储</li><li><strong>可以把任意的二进制（图片、视频、音频、字符串）转成可打印的字符</strong></li></ul><p>原理：</p><ul><li>由来 2^6=64位二进制，把所有字符串转成二进制然后每6位一个转成base64</li><li>编码后的长度要是4的倍数，不是则需最后补上一个等号</li></ul><h2 id="chrome-js" tabindex="-1"><a class="header-anchor" href="#chrome-js"><span>Chrome &amp; JS</span></a></h2><h3 id="f12-crul" tabindex="-1"><a class="header-anchor" href="#f12-crul"><span>F12-crul</span></a></h3><p>f12 右键一个请求 copy as cURL 可以得到一个 curl 命令集， Ant Work 中就是这样给我们接口信息，我们组数据做 QA 对语料喂给 GPT</p><h3 id="chrome-url" tabindex="-1"><a class="header-anchor" href="#chrome-url"><span>Chrome-Url</span></a></h3><blockquote><p>url地址栏区分大小写吗</p></blockquote><p>在大多数常见的浏览器中，URL地址栏通常是不区分大小写的。这意味着无论您输入的是大写字母、小写字母还是大小写混合，浏览器都会将其视为相同的URL。</p><p>例如，以下URL在地址栏中是等效的：</p><p>复制</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>http://www.example.com</span></span>\n<span class="line"><span>HTTP://WWW.EXAMPLE.COM</span></span>\n<span class="line"><span>http://www.Example.com</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过需要注意的是，尽管地址栏不区分大小写，但是URL路径和查询参数部分可能会受到服务器的影响。某些服务器可能会对URL路径和查询参数进行区分大小写的处理。这意味着在特定的服务器环境中，<code>/path</code> 和 <code>/Path</code> 可能被视为不同的路径。</p><p>在Spring Boot中，默认情况下，<code>@GetMapping(&quot;/A&quot;)</code> 和 <code>@GetMapping(&quot;/a&quot;)</code> 是被视为两个不同的路径的。这是因为Spring Boot默认情况下是区分路径的大小写的。</p><p>所以，当您使用<code>@GetMapping(&quot;/A&quot;)</code>注解时，它将映射到路径<code>/A</code>，而<code>@GetMapping(&quot;/a&quot;)</code>将映射到路径<code>/a</code>。这两个路径被视为不同的URL。</p><p>如果您希望路径大小写不敏感，即<code>/A</code>和<code>/a</code>被视为相同的路径，可以在Spring Boot的配置中进行相应的设置。您可以在<code>application.properties</code>或<code>application.yml</code>文件中添加以下配置：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>spring.mvc.pathmatch.matching-strategy=ant_path_matcher</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p>What does %2F mean in a URL? ASCII Encoding Reference</p></blockquote><p>场景：我用电脑识别 QR_Code 到 URL 浏览器 发现把里面的 <code>/</code> 全部转移成 <code>%2F</code> 了</p><p>联想到 <code>空格</code> 是 <code>%20</code> 于是系统总结下：</p><p>常见的需要转义的字符：https://www.w3schools.com/tags/ref_urlencode.ASP</p><p>在线 URLDecode 解码工具</p><h3 id="f12-js" tabindex="-1"><a class="header-anchor" href="#f12-js"><span>F12-JS</span></a></h3><blockquote><p>实用 JS 到 Console</p></blockquote><p>1）复制一个 input 的 Selector, <strong>我这里也有便捷方式，发现input有个 <code>readonly</code> 控制的不可编辑！！！把这个删了就行！~</strong></p><p>在 JavaScript 字符串中需要转义的特殊字符：</p><ul><li>反斜杠 <code>\\</code>: 反斜杠用于转义后面的字符，例如 <code>\\\\</code> 表示一个普通的反斜杠字符。</li><li>引号 <code>&quot;</code> 和 <code>&#39;</code>: 如果字符串本身包含引号，需要使用反斜杠进行转义，例如 <code>\\&quot;</code> 或 <code>\\&#39;</code>。</li><li>换行符 <code>\\n</code>: 表示换行。</li><li>回车符 <code>\\r</code>: 表示回车。</li><li>制表符 <code>\\t</code>: 表示水平制表符。</li></ul><figure><img src="http://pub-83c20763effa4ac69b4d6a9e22c9936e.r2.dev/img/image-20231120173938571.png" alt="image-20231120173938571" tabindex="0" loading="lazy"><figcaption>image-20231120173938571</figcaption></figure><p>2）js如何给td标签设置值</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//tdElement 可以通过 getElementById / querySelector 获取</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">tdElement</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">innerHTML</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;新的值&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 设置 &lt;td&gt; 的内容</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">tdElement</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">textContent</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;新的值&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">tdElement</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">innerText</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;新的值&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="chrome-shortcutkey" tabindex="-1"><a class="header-anchor" href="#chrome-shortcutkey"><span>Chrome-ShortcutKey</span></a></h3><blockquote><p><a href="https://support.google.com/chrome/answer/157179" target="_blank" rel="noopener noreferrer">Chrome 官网快捷键总结</a></p></blockquote><table><thead><tr><th style="text-align:left;">操作</th><th>快捷键</th></tr></thead><tbody><tr><td style="text-align:left;">为网站名称添加 <code>www.</code> 和 <code>.com</code>，然后在当前标签页中打开该网址</td><td>输入网站名称并按 <strong>Ctrl + Enter</strong> 键</td></tr><tr><td style="text-align:left;">打开新的标签页并执行 Google 搜索</td><td>输入搜索字词并按 Alt + Enter 键</td></tr><tr><td style="text-align:left;">跳转到地址栏</td><td><strong>Ctrl + l</strong> 或 Alt + d 或 F6</td></tr></tbody></table><ul><li><p>shift+esc 任务管理器</p></li><li><p><strong>ctrl+shift+delete 清缓存必备</strong></p></li><li><p>F12 == ctrl+shift+i</p></li></ul><blockquote><p>搜索技巧</p></blockquote><p>只搜索某个站点： 空格域名</p><p>排除某个站点： 空格 -域名</p><h3 id="html-刷新" tabindex="-1"><a class="header-anchor" href="#html-刷新"><span>HTML 刷新</span></a></h3><p>让网页多长时间（秒）刷新自己，或在多长时间后让网页自动链接到其它网页。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://www.baidu.com/&quot;&gt;</span></span>\n<span class="line"><span>or</span></span>\n<span class="line"><span>&lt;body onload=&quot;parent.location=&#39;http://www.baidu.com&#39;&quot;&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="curl" tabindex="-1"><a class="header-anchor" href="#curl"><span>Curl</span></a></h2><blockquote><p>https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</p></blockquote><p>curl -XPOST localhost:8888/user -d &#39;id=42&#39; -d &#39;name=Tom&#39; (POST学习！！)</p><p>curl -XPOST localhost:8888/user -H &#39;Content-Type:application/json&#39; -d &#39;{&quot;id&quot;:42, &quot;name&quot;:&quot;Tom&quot;}&#39;</p><ul><li>使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。</li></ul>',62),d={},h=(0,t(9874).A)(d,[["render",function(e,i){const t=(0,l.g2)("center"),d=(0,l.g2)("font");return(0,l.uX)(),(0,l.CE)("div",null,[s,(0,l.bF)(t,null,{default:(0,l.k6)((()=>[(0,l.eW)("---扩展知识---")])),_:1}),a,(0,l.Lk)("ul",null,[(0,l.Lk)("li",null,[o,(0,l.eW)(": 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，"),(0,l.bF)(d,{color:"red"},{default:(0,l.k6)((()=>[(0,l.eW)("通常而言session都是保存在内存")])),_:1}),(0,l.eW)("中，而随着"),n,(0,l.eW)("。")]),r,p]),c])}]]),u=JSON.parse('{"path":"/code/408-Network/HttpRequest.html","title":"HttpRequest","lang":"zh-CN","frontmatter":{"article":false,"description":"HttpRequest http 请求包含哪几个部分（请求行、请求头、请求体） 这里放一些常见的，具体的去搜 一、General（请求行） Request URL: http://127.0.0.1:8848/nacos/ Request Method: GET Status Code:304（响应状态码） Remote Address: 127.0....","head":[["meta",{"property":"og:url","content":"https://zzq8.cn/code/408-Network/HttpRequest.html"}],["meta",{"property":"og:site_name","content":"Piglet"}],["meta",{"property":"og:title","content":"HttpRequest"}],["meta",{"property":"og:description","content":"HttpRequest http 请求包含哪几个部分（请求行、请求头、请求体） 这里放一些常见的，具体的去搜 一、General（请求行） Request URL: http://127.0.0.1:8848/nacos/ Request Method: GET Status Code:304（响应状态码） Remote Address: 127.0...."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:image","content":"http://pub-83c20763effa4ac69b4d6a9e22c9936e.r2.dev/img/image-20231120173938571.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Piglet"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"HttpRequest\\",\\"description\\":\\"HttpRequest http 请求包含哪几个部分（请求行、请求头、请求体） 这里放一些常见的，具体的去搜 一、General（请求行） Request URL: http://127.0.0.1:8848/nacos/ Request Method: GET Status Code:304（响应状态码） Remote Address: 127.0....\\"}"]]},"headers":[{"level":2,"title":"一、General（请求行）","slug":"一、general-请求行","link":"#一、general-请求行","children":[]},{"level":2,"title":"二、Request Headers（请求头）","slug":"二、request-headers-请求头","link":"#二、request-headers-请求头","children":[]},{"level":2,"title":"三、Response Headers（响应头）","slug":"三、response-headers-响应头","link":"#三、response-headers-响应头","children":[]},{"level":2,"title":"四、XHR","slug":"四、xhr","link":"#四、xhr","children":[]},{"level":2,"title":"Session 缺点","slug":"session-缺点","link":"#session-缺点","children":[{"level":3,"title":"为什么要使用Session技术？","slug":"为什么要使用session技术","link":"#为什么要使用session技术","children":[]},{"level":3,"title":"Sessin 缺点：","slug":"sessin-缺点","link":"#sessin-缺点","children":[]}]},{"level":2,"title":"Cookie","slug":"cookie","link":"#cookie","children":[]},{"level":2,"title":"token","slug":"token","link":"#token","children":[]},{"level":2,"title":"计网面试题","slug":"计网面试题","link":"#计网面试题","children":[{"level":3,"title":"TCP和UDP的区别，TCP靠什么保证可靠连接？","slug":"tcp和udp的区别-tcp靠什么保证可靠连接","link":"#tcp和udp的区别-tcp靠什么保证可靠连接","children":[]},{"level":3,"title":"讲一下TCP三次握手 为什么要3次，两次或者四次不行吗","slug":"讲一下tcp三次握手-为什么要3次-两次或者四次不行吗","link":"#讲一下tcp三次握手-为什么要3次-两次或者四次不行吗","children":[]}]},{"level":2,"title":"Base64","slug":"base64","link":"#base64","children":[]},{"level":2,"title":"Chrome & JS","slug":"chrome-js","link":"#chrome-js","children":[{"level":3,"title":"F12-crul","slug":"f12-crul","link":"#f12-crul","children":[]},{"level":3,"title":"Chrome-Url","slug":"chrome-url","link":"#chrome-url","children":[]},{"level":3,"title":"F12-JS","slug":"f12-js","link":"#f12-js","children":[]},{"level":3,"title":"Chrome-ShortcutKey","slug":"chrome-shortcutkey","link":"#chrome-shortcutkey","children":[]},{"level":3,"title":"HTML 刷新","slug":"html-刷新","link":"#html-刷新","children":[]}]},{"level":2,"title":"Curl","slug":"curl","link":"#curl","children":[]}],"git":{"createdTime":1712997543000,"contributors":[{"name":"Fighting","email":"1024zzq@gmail.com","commits":2},{"name":"MacAir","email":"1024zzq@gmail.com","commits":1},{"name":"MiniPC","email":"1024zzq@gmail.com","commits":1}]},"readingTime":{"minutes":13.16,"words":3949},"filePathRelative":"code/408-Network/HttpRequest.md","localizedDate":"2024年4月13日","excerpt":"\\n<p><a href=\\"https://blog.csdn.net/f110300641/article/details/115342356\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">http 请求包含哪几个部分（请求行、请求头、请求体）</a></p>","autoDesc":true}')}}]);