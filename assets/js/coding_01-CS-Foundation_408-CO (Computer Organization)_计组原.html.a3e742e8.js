"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[9489],{9874:(a,e)=>{e.A=(a,e)=>{const n=a.__vccOpts||a;for(const[a,t]of e)n[a]=t;return n}},8645:(a,e,n)=>{n.r(e),n.d(e,{comp:()=>l,data:()=>h});var t=n(2360);const s=(0,t.Fv)('<h1 id="计组原" tabindex="-1"><a class="header-anchor" href="#计组原"><span>计组原</span></a></h1><h1 id="一、内存" tabindex="-1"><a class="header-anchor" href="#一、内存"><span>一、<a href="https://zhuanlan.zhihu.com/p/41187907" target="_blank" rel="noopener noreferrer">内存</a></span></a></h1><h2 id="_1-理论" tabindex="-1"><a class="header-anchor" href="#_1-理论"><span>1. 理论</span></a></h2><h4 id="_1-前言" tabindex="-1"><a class="header-anchor" href="#_1-前言"><span>1. 前言</span></a></h4><p><strong>内存是计算机系统的主存储器</strong> 介绍上面两个存储单位后就介绍下内存了。 <strong>内存作为1个存储数据的存在， 有1个很重要的特性， 就是内存里的数据能被cpu直接访问。</strong> cpu能不能直接访问硬盘的数据呢， 不能。 只能通过把硬盘的数据先放到内存里， 然后再从内存里访问硬盘的数据。我们平时玩游戏碰上读图loading 进度条的这个过程， 就是把数据从硬盘读到内存的过程啊。 读完条后地图的数据就在内存中了。 所以内存才是计算机系统的主存储器， 而硬盘是被分到跟光盘..u盘一类都是外部存储器</p><h4 id="_2-直接寻址技术" tabindex="-1"><a class="header-anchor" href="#_2-直接寻址技术"><span>2. 直接寻址技术</span></a></h4><p>当代计算机还实现了1个逆天的技术,就是直接寻址了. 什么意思呢, 还是用上面的例子说明, 假如你知道你要找的人住在那栋大楼的17楼 1702, 但是你还是需要从1楼走到17楼去找他, 这个过程还是需要时间成本的.</p><p>但是如果你具有了直接寻址技术, 就能直接跳到17楼 1702门前, 如果你找的下1个人在2楼, 又能从17楼直接跳到2楼, 逆天啊. 而直接寻址技术已经成为当代计算机软硬件的标准技术之一了, 也就是说只要cpu知道要访问数据的内存地址, 就能直接到内存的对应位置去访问数据!</p><h4 id="_3-内存地址的表示方式" tabindex="-1"><a class="header-anchor" href="#_3-内存地址的表示方式"><span>3. 内存地址的表示方式</span></a></h4><p>跟门牌号一样, 其实内存地址也是由1个2进制数字来表示的. 每1个地址对应内存里的1个byte字节, 如果地址的值加1, 那么这个地址就对应下1个字节了.</p><p>那么内存地址的长度是多少呢? 这个就是这篇文章标题所涉及的. 在32位操作系统中, <strong>内存的地址就是32位的2进制数</strong>, 那么假如32位系统的某个内存地址是: 0000 1111 1111 0000 1111 0000 1111 0000 那么它可以用十六进制表示成: 0 F F 0 F 0 F 0 也就是 <strong>Ox</strong>0ff0f0f0 前面Ox代表十六进制, 所以你见到这种字母数字混合一次的地址方式,就是这样得来的了, 它实际上是1个二进制的数字啊. 不过计算机里面所有的东西都是二进制了..</p><h4 id="_4-内存地址的数量决定cpu能访问的内存大小" tabindex="-1"><a class="header-anchor" href="#_4-内存地址的数量决定cpu能访问的内存大小"><span>4. <mark>内存地址的数量决定cpu能访问的内存大小</mark></span></a></h4><p>上面说了, 既然32位系统里内存地址长度是32位的. 所以32位的地址范围就是从 0000 0000 0000 0000 0000 0000 0000 0000 到 1111 1111 1111 1111 1111 1111 1111 1111 啦（Ox00000000 ~ OxFFFFFFFF)， 这里有几个地址呢？ 明显是有 2^32 个啦.</p><p>那么2^32到底是多少个？ 2^32 = 4 * 1024(G) * 1024(M) * 1024(K) = 4294967296 , 就是<strong>4G</strong> 啊, 而每1个地址对应1个1个字节， 容量就是1byte， 所以2^32个地址就总共能对应应<strong>4GB</strong> 的内存容量啊， 这里的B指的是byte 字节啊。</p><p><mark>假如你给32位的系统配上了8GB的内存， 操作系统最多也只能给其中4GB 分配地址， 其余 4GB 是没有地址， 因为地址不够用啊， 所以32位系统最多支持4GB内存就是这样来的。</mark></p><h4 id="补充评论-没有深入探究了、尽信书-不如无书" tabindex="-1"><a class="header-anchor" href="#补充评论-没有深入探究了、尽信书-不如无书"><span>补充评论（没有深入探究了、尽信书，不如无书）</span></a></h4><p>这个转载的文章误人子弟了。前面说的都对，后面就驴头不对马嘴了。32位操作系统，指的是寄存器是32位，一次内存数据流宽度是32位。但是不是说内存地址也必须32位。内存大小是由硬件和操作系统两个方面决定的。硬件是地址总线，地址总线如果是32个，那么就最多支持4G，但是地址总线一般大于等于数据总线，如果地址总线是36个，那么硬件支持内存就大于4G了。还有操作系统，那是虚拟地址了。就算地址总线有36个，操作系统支持的虚拟地址只有32位，那也仅仅支持4G内存。内存大小是由硬件和操作系统两方制约的（还有其他小的制约因素）。至于文中说的32位操作系统，指的是寄存器位数，和内存大小没多大关系。地址总线36位，如果寄存器位数32位，可以通过读取两次，完成内存地址定位。</p><h2 id="_2-实际" tabindex="-1"><a class="header-anchor" href="#_2-实际"><span>2. <a href="https://blog.csdn.net/Castlehe/article/details/117566303" target="_blank" rel="noopener noreferrer">实际</a></span></a></h2><h4 id="_1-线程数和逻辑cpu个数-内核个数" tabindex="-1"><a class="header-anchor" href="#_1-线程数和逻辑cpu个数-内核个数"><span>1. 线程数和逻辑CPU个数，内核个数</span></a></h4><p><strong>1 CPU 4 Core 8 Thread</strong></p><p>在任务管理器中，看到其实是4个内核，但是逻辑处理器是8个，有多少个逻辑处理器，就可以开多少个线程。 <strong>线程数=逻辑处理器个数</strong><img src="https://img-blog.csdnimg.cn/20210604164533979.png" alt="在这里插入图片描述" style="zoom:25%;"></p>',21),i=(0,t.Lk)("li",null,[(0,t.eW)("一个"),(0,t.Lk)("code",null,"物理内核"),(0,t.eW)("可以作为1个或者2个"),(0,t.Lk)("code",null,"逻辑CPU")],-1),r=(0,t.Fv)('<blockquote><p>操作系统可以使用逻辑CPU来模拟真实CPU。 在没有多核处理器的时候，一个物理CPU只能有一个物理内核， 有了多核技术，一个物理CPU可以有多个物理内核，可以把一个CPU当作多个CPU使用，即逻辑CPU。 没有开启超线程时，逻辑CPU的个数就是总的CPU物理内核数。 开启超线程后，逻辑CPU的个数就是总的CPU物理内核数的两倍。</p></blockquote><p>实际能看到的2个物理CPU:</p><img src="https://img-blog.csdnimg.cn/20210604165526341.png" style="zoom:50%;"><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> multiprocessing </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> cpu_count</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#61AFEF;">cpu_count</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">())</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 8</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在python中，使用上述代码可以获取当前系统的逻辑cpu个数，也就是<mark>支持并发的线程个数。</mark></p>',5),p={},l=(0,n(9874).A)(p,[["render",function(a,e){const n=(0,t.g2)("font");return(0,t.uX)(),(0,t.CE)("div",null,[s,(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,[(0,t.bF)(n,{color:"red"},{default:(0,t.k6)((()=>[(0,t.eW)("一个`物理CPU`可以有1个或者多个`物理内核`")])),_:1})]),i]),r])}]]),h=JSON.parse('{"path":"/coding/01-CS-Foundation/408-CO%20(Computer%20Organization)/%E8%AE%A1%E7%BB%84%E5%8E%9F.html","title":"计组原","lang":"zh-CN","frontmatter":{"article":false,"description":"计组原 一、内存 1. 理论 1. 前言 内存是计算机系统的主存储器 介绍上面两个存储单位后就介绍下内存了。 内存作为1个存储数据的存在， 有1个很重要的特性， 就是内存里的数据能被cpu直接访问。 cpu能不能直接访问硬盘的数据呢， 不能。 只能通过把硬盘的数据先放到内存里， 然后再从内存里访问硬盘的数据。我们平时玩游戏碰上读图loading 进度条...","head":[["meta",{"property":"og:url","content":"https://zzq8.cn/coding/01-CS-Foundation/408-CO%20(Computer%20Organization)/%E8%AE%A1%E7%BB%84%E5%8E%9F.html"}],["meta",{"property":"og:site_name","content":"Piglet"}],["meta",{"property":"og:title","content":"计组原"}],["meta",{"property":"og:description","content":"计组原 一、内存 1. 理论 1. 前言 内存是计算机系统的主存储器 介绍上面两个存储单位后就介绍下内存了。 内存作为1个存储数据的存在， 有1个很重要的特性， 就是内存里的数据能被cpu直接访问。 cpu能不能直接访问硬盘的数据呢， 不能。 只能通过把硬盘的数据先放到内存里， 然后再从内存里访问硬盘的数据。我们平时玩游戏碰上读图loading 进度条..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Piglet"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"计组原\\",\\"description\\":\\"计组原 一、内存 1. 理论 1. 前言 内存是计算机系统的主存储器 介绍上面两个存储单位后就介绍下内存了。 内存作为1个存储数据的存在， 有1个很重要的特性， 就是内存里的数据能被cpu直接访问。 cpu能不能直接访问硬盘的数据呢， 不能。 只能通过把硬盘的数据先放到内存里， 然后再从内存里访问硬盘的数据。我们平时玩游戏碰上读图loading 进度条...\\"}"]]},"headers":[{"level":2,"title":"1. 理论","slug":"_1-理论","link":"#_1-理论","children":[]},{"level":2,"title":"2. 实际","slug":"_2-实际","link":"#_2-实际","children":[]}],"git":{"createdTime":1712997543000,"contributors":[{"name":"MacAir","email":"1024zzq@gmail.com","commits":1}]},"readingTime":{"minutes":5.15,"words":1545},"filePathRelative":"coding/01-CS-Foundation/408-CO (Computer Organization)/计组原.md","localizedDate":"2024年4月13日","excerpt":"\\n<h1><a class=\\"header-anchor\\" href=\\"#一、内存\\"><span>一、</span></a><a href=\\"https://zhuanlan.zhihu.com/p/41187907\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">内存</a></h1>","autoDesc":true}')}}]);